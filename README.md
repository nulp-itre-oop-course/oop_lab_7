# Робота з динамічними масивами
**Мета**: Створити, відлагодити та протестувати програму, у якій створити клас для обробки даних. Одним з членів класу є масив структур, в якому зберігаються введені дані.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ з класом для обробки даних та реалізувати конструктор, деструктор, методи класу. Одним з членів класу є динамічний масив структур, в якому зберігаються введені дані. Також методи зміни полів класу повинні перевіряти валідність заданих змінних. Потрібно   реалізувати проєкт у середовищі Visual Studio Code для створення багатофайлових програм.
1. Ознайомитися із властивостями контейнера `std::vector` та його методами. Обдумати способи його використання для створення програм.
2. Вибрати завдання згідно свого варіанту у ДОДАТКУ.
3. Розробити блок-схему алгоритму програми.
4. Реалізувати програму для виводу даних полів (членів) масиву структур вкладених у клас.

## Короткі відомості
Введений в стандарт C++03, `std::vector` (або просто “вектор”) — це динамічний масив, який може сам керувати виділеною йому пам’яттю. Це означає, що ви можете створювати масиви, довжина яких задається під час виконання, без використання операторів new і delete (явної вказівки на виділення і звільнення пам’яті). `std::vector` знаходиться в заголовку `vector`. 
Оголошення `std::vector` відбувається таким чином:
```c++
#include <vector>
// Немає необхідності вказувати довжину при ініціалізації
std::vector<int> array; 
std::vector<int> array = {0}; 
std::vector<int> array2 = { 10, 8, 6, 4, 2, 1 }; // використовується список ініціалізаторів для ініціалізації масиву
std::vector<int> array3 { 10, 8, 6, 4, 2, 1 }; // використовується uniform-ініціалізація для ініціалізації масиву (починаючи з C++11)
```
Як і в неініціалізованому, так і в ініціалізованому випадках вам не потрібно явно вказувати довжину масивів. Це пов’язано з тим, що std::vector динамічно виділяє пам’ять для свого вмісту за запитом. Подібно `std::array`, доступ до елементів масиву може виконуватися як через оператор `[]` (який не виконує перевірку діапазону), так і через функцію `at()` (яка виконує перевірку діапазону).
Коли змінна-вектор виходить з області видимості, вона автоматично звільняє пам’ять, яку контролювала (займала). Це не тільки зручно (так як вам не потрібно це робити вручну), але також допомагає запобігти витокам пам’яті.
Детальніше про контейнер std::array можна дізнатися із онлайн довідника [std::vector - cppreference.com](https://en.cppreference.com/w/cpp/container/vector) 

![](images/stdvector-cpp.reference_element_access.png)
![](images/stdvector-cpp.reference_iterators.png)
![](images/stdvector-cpp.reference_capacity.png)
![](images/stdvector-cpp.reference_modifiers.png)

## Хід роботи:
Рекомендації до роботи:
1. продумайте, які типи змінних вам потрібно використати для виконання завдання.
2. створіть проєкт із кількома файлами, тобто крім основного файлу, наприклад main.cpp, додайте два файли, наприклад `student.h` та `student.cpp`. Для цього потрібно виправити файл `..\.vscode\tasks.json`, а саме замість відносного шляху до виконуваного файла `"${file}"` вказати відносний шлях директорії проєкту до всіх файлів `/*.cpp`, `/*.h`, наприклад `"${workspaceFolder}/*.cpp","${workspaceFolder}/*.h"`:
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++.exe build active file",
            "command": "C:\\msys64\\ucrt64\\bin\\g++.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${workspaceFolder}/*.cpp",
                "${workspaceFolder}/*.h",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "compiler: C:\\msys64\\ucrt64\\bin\\g++.exe"
        }
    ]
}
```
3. У заголовному файлі `*.h` оголосіть клас:
```c++
class Student{
    private:
    std::vector<Student> students {0}; 
    …
}
```
4. оголосіть відповідну структуру, наприклад `student_s_t`, перед оголошенням класу:
```c++
struct student_s_t{
    int id;
    std::string name;
    int course;
};
```
5. реалізуйте для класу конструктор та деструктор.
6. реалізуйте методи класу для введення і виведення даних.
7. методи зміни полів класу повинні перевіряти валідність заданих змінних і попереджувати користувача про некоректні значення.
8. реалізуйте методи обробки даних: додавання, вставки, вилучення, обміну, очищення (видалення).
9. можете збільшити кількість членів класу додатковими полями чи методами.
10. програма має вивести на консоль (термінал) вхідні дані та результат виконання.

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1. Блок-схему алгоритму програми.
2. Код (лістинг) програми.
3. Результати тестування для різних вхідних умов.
4. Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |              Клас             |                              Поля класу                                 |
|----|-------------------------------|-------------------------------------------------------------------------|
|  1 | Резистор                      | Номінальний опір, максимальна потужність розсіяння, клас точності       |
|  2 | Конденсатор                   | Номінальна ємність, максимальна напруга, тип матеріалу                  |
|  3 | Транзистор                    | Тип, коефіцієнт підсилення, максимальний струм                          |
|  4 | Діод                          | Пряма напруга, максимальний зворотний струм, призначення                |
|  5 | Операційний підсилювач        | Коефіцієнт підсилення, напруга живлення, кількість входів               |
|  6 | Котушка індуктивності         | Індуктивність, опір, кількість витків                                   |
|  7 | Радіопередавач                | Робоча частота, потужність, тип модуляції                               |
|  8 | Антена                        | Тип, коефіцієнт підсилення, частотний діапазон                          |
|  9 | Радіоприймач                  | Робоча частота, чутливість, тип модуляції                               |
| 10 | Осцилограф                    | Кількість каналів, смуга пропускання, тип (аналоговий/цифровий)         |
| 11 | Акумулятор                    | Ємність, напруга, тип матеріалу                                         |
| 12 | Мікросхема                    | Назва/маркування, кількість виводів, напруга живлення                   |
| 13 | Коаксіальний кабель           | Хвильовий опір, діаметр, довжина                                        |
| 14 | Датчик температури            | Тип, діапазон вимірювання, точність                                     |
| 15 | Друкована плата               | Ширина, довжина, кількість шарів                                        |
| 16 | Світлодіод                    | Колір, робочий струм, напруга                                           |
| 17 | Оптоволоконний кабель         | Кількість волокон, тип, довжина                                         |
| 18 | Аналого-цифровий перетворювач | Розрядність, частота дискретизації, кількість каналів                   |
| 19 | Мікроконтролер                | Архітектура, частота, кількість портів                                  |
| 20 | Радіореле                     | Напруга котушки, максимальний струм комутації, кількість груп контактів |
| 21 | Акустичний динамік            | Опір, потужність, діаметр                                               |
| 22 | Трансформатор                 | Коефіцієнт трансформації, первинна напруга, потужність                  |
| 23 | Генератор сигналів            | Тип сигналу, максимальна частота, наявність модуляції                   |
| 24 | Атенюатор                     | Коефіцієнт послаблення, максимальна потужність, тип                     |
| 25 | Електронний фільтр            | Тип, частота зрізу, порядок                                             |
| 26 | Телевізор                     | Діагональ екрану, роздільна здатність, наявність Smart-TV               |
| 27 | Супутник зв’язку              | Тип орбіти, кількість транспондерів, частотний діапазон                 |
| 28 | Роутер                        | Швидкість передавання даних, стандарт WiFi, кількість портів LAN        |
| 29 | Сигналізація                  | Кількість датчиків, наявність бездротових сенсорів, спосіб оповіщення   |
| 30 | Ретранслятор                  | Коефіцієнт підсилення, тип, робоча частота                              |
